# 双指针与滑动窗口 (Two Pointers & Sliding Window)

## 核心哲学
双指针技巧的本质是**利用数组的单调性（有序性）或问题的连续性**，通过两个指针的移动，将原本需要两层嵌套循环 ($O(N^2)$) 的搜索空间，优化为单次遍历 ($O(N)$)。

---

## 一、 通解与模板：三大思维模式

### 1. 左右指针 (对撞指针 / Opposite Pointers)
**核心思想**：指针从两端向中间汇合。
**适用场景**：有序数组搜索、反转、回文判断、接雨水。

**口诀**：
1. **排序是前提**（搜索类题目）。
2. **双向奔赴**：根据当前和与目标值的关系，移动左或右指针。

```js
// 左右指针通用模板
var oppositePointers = function(nums) {
    let left = 0, right = nums.length - 1;
    while (left < right) {
        let sum = nums[left] + nums[right];
        if (sum === target) {
            return [left, right];
        } else if (sum < target) {
            left++; // 让 sum 变大
        } else {
            right--; // 让 sum 变小
        }
    }
};
```

### 2. 快慢指针 (同向指针 / Fast-Slow Pointers)
**核心思想**：两个指针同向移动，速度不同或起点不同。
**适用场景**：
- **数组**：原地修改（去重、移动元素）。
- **链表**：找中点、判断环、找倒数第 K 个。

```js
// 快慢指针模板 (原地修改数组)
var fastSlowPointers = function(nums) {
    let slow = 0, fast = 0;
    while (fast < nums.length) {
        // 这里的条件通常是：nums[fast] 是否是一个需要保留的“合格”元素
        if (/* nums[fast] 满足条件 */) {
            nums[slow] = nums[fast];
            slow++;
        }
        fast++;
    }
    return slow; // 返回新长度
};
```

### 3. 滑动窗口 (Sliding Window - 最强模板)
**核心思想**：维护一个“窗口”，通过扩大和缩小窗口来寻找满足条件的子区间。
**适用场景**：子串匹配、连续子数组和/长度。

**万能模板 (背诵全文)**：
```js
/* 滑动窗口万能模板 */
var slidingWindow = function(s, t) {
    // 1. 初始化窗口及其辅助数据结构
    let need = new Map();   // 我们需要的字符及其频率
    let window = new Map(); // 窗口中当前的字符及其频率
    for (let c of t) need.set(c, (need.get(c) || 0) + 1);
    
    let left = 0, right = 0;
    let valid = 0; // 窗口中满足 need 条件的字符种类数
    let res = /* 根据题目要求初始化 */;

    while (right < s.length) {
        // a. 【入窗】：c 是将要移入窗口的字符
        let c = s[right];
        right++; // 右移窗口
        
        // --- 进行窗口内数据的一系列更新 ---
        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) === need.get(c)) valid++;
        }

        // b. 【收缩】：判断左侧窗口是否要收缩
        // 对于求“最小”窗口：当满足条件时收缩，以寻找更短的可能
        // 对于求“最大”窗口：当不满足限制时收缩，以恢复合法状态
        while (/* window needs shrink */) {
            // d 是将要移出窗口的字符
            let d = s[left];
            left++; // 左移窗口
            
            // --- 进行窗口内数据的一系列更新 ---
            if (need.has(d)) {
                if (window.get(d) === need.get(d)) valid--;
                window.set(d, window.get(d) - 1);
            }
        }
        
        // c. 【更新结果】：根据题目要求在合适的位置更新 res
        // 如果求最大长度，通常在 while 外更新：res = Math.max(res, right - left)
        // 如果求最小长度，通常在 while 内更新：res = Math.min(res, right - left)
    }
    return res;
};
```

---

## 二、 记忆心法总结

1.  **看到“有序数组” + “目标值”** -> 优先想 **左右指针**。
2.  **看到“连续子数组/子串” + “最长/最短/计数”** -> 优先想 **滑动窗口**。
3.  **看到“原地修改”或“链表环”** -> 优先想 **快慢指针**。
4.  **滑动窗口四问**：
    -   什么时候应该扩大窗口 (`right++`)？
    -   什么时候应该缩小窗口 (`left++`)？
    -   扩大/缩小窗口时，应该更新哪些数据？
    -   我们要的结果是在扩大时更新，还是在缩小时更新？

---

## 三、 经典题型深度解析

### 1. 三数之和 (15. 3Sum)
**核心**：排序 + 固定一个数 + 左右指针。
**难点**：去重。

```js
var threeSum = function(nums) {
    nums.sort((a, b) => a - b);
    const res = [];
    for (let i = 0; i < nums.length - 2; i++) {
        if (nums[i] > 0) break; // 优化：第一个数大于0，和不可能为0
        if (i > 0 && nums[i] === nums[i-1]) continue; // 去重第一个数
        
        let l = i + 1, r = nums.length - 1;
        while (l < r) {
            let sum = nums[i] + nums[l] + nums[r];
            if (sum === 0) {
                res.push([nums[i], nums[l], nums[r]]);
                while (l < r && nums[l] === nums[l+1]) l++; // 去重左指针
                while (l < r && nums[r] === nums[r-1]) r--; // 去重右指针
                l++; r--;
            } else if (sum < 0) l++;
            else r--;
        }
    }
    return res;
};
```

### 2. 无重复字符的最长子串 (3. Longest Substring Without Repeating Characters)
**核心**：滑动窗口基础题。
**思路**：维护一个窗口，保证窗口内没有重复字符。当新加入的字符导致重复时，收缩左边界直到重复消除。

```js
var lengthOfLongestSubstring = function(s) {
    let window = new Map();
    let left = 0, right = 0;
    let res = 0;

    while (right < s.length) {
        let c = s[right];
        right++;
        // 进行窗口内数据的一系列更新
        window.set(c, (window.get(c) || 0) + 1);

        // 判断左侧窗口是否要收缩
        while (window.get(c) > 1) {
            let d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            window.set(d, window.get(d) - 1);
        }
        
        // 更新结果
        res = Math.max(res, right - left);
    }
    return res;
};
```

### 3. 长度最小的子数组 (209. Minimum Size Subarray Sum)
**核心**：滑动窗口求最小窗口。
**思路**：窗口和小于 target 时右移扩大，大于等于 target 时左移缩小并更新最小长度。

```js
var minSubArrayLen = function(target, nums) {
    let left = 0, right = 0;
    let sum = 0;
    let res = Infinity;

    while (right < nums.length) {
        let c = nums[right];
        right++;
        // 窗口内数据更新
        sum += c;

        // 收缩窗口条件：sum >= target
        while (sum >= target) {
            // 更新结果：在收缩前/后均可，这里是满足条件即更新
            res = Math.min(res, right - left);
            
            let d = nums[left];
            left++;
            // 窗口内数据更新
            sum -= d;
        }
    }
    return res === Infinity ? 0 : res;
};
```

### 4. 最小覆盖子串 (76. Minimum Window Substring)
**核心**：滑动窗口模板的完美体现。

```js
var minWindow = function(s, t) {
    let need = new Map(), window = new Map();
    for (let c of t) need.set(c, (need.get(c) || 0) + 1);
    
    let left = 0, right = 0, valid = 0;
    let start = 0, len = Infinity; // 记录最小覆盖子串的起点和长度

    while (right < s.length) {
        let c = s[right++];
        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) === need.get(c)) valid++;
        }

        while (valid === need.size) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            let d = s[left++];
            if (need.has(d)) {
                if (window.get(d) === need.get(d)) valid--;
                window.set(d, window.get(d) - 1);
            }
        }
    }
    return len === Infinity ? "" : s.substr(start, len);
};
```

### 5. 滑动窗口最大值 (239. Sliding Window Maximum)
**核心**：单调队列 (Monotonic Queue) + 滑动窗口。
**思路**：维护一个单调递减队列，队列头部始终是当前窗口的最大值下标。

```js
var maxSlidingWindow = function(nums, k) {
    let deque = []; // 存下标，对应值单调递减
    let res = [];
    
    for (let i = 0; i < nums.length; i++) {
        // 1. 入队：保持单调递减，移除比当前元素小的队尾元素
        while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        deque.push(i);
        
        // 2. 出队：判断队头是否滑出窗口
        if (deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // 3. 记录结果：当窗口形成时 (i >= k - 1)
        if (i >= k - 1) {
            res.push(nums[deque[0]]);
        }
    }
    return res;
};
```

### 6. 接雨水 (42. Trapping Rain Water)
**核心**：双指针极致优化空间。

```js
var trap = function(height) {
    let left = 0, right = height.length - 1;
    let l_max = 0, r_max = 0;
    let res = 0;
    
    while (left < right) {
        l_max = Math.max(l_max, height[left]);
        r_max = Math.max(r_max, height[right]);
        
        // 核心逻辑：木桶效应，水的高度取决于较低的那一边
        if (l_max < r_max) {
            res += l_max - height[left];
            left++;
        } else {
            res += r_max - height[right];
            right--;
        }
    }
    return res;
};
```

---

## 五、 广义双指针与数组技巧拓展

### 1. 贪心策略 (Greedy Strategy)
**121. 买卖股票的最佳时机 (Best Time to Buy and Sell Stock)**
**核心**：一次遍历。记录历史最低点，计算当前卖出的最大利润。

```js
var maxProfit = function(prices) {
    let minPrice = Infinity;
    let maxProfit = 0;
    for (let price of prices) {
        if (price < minPrice) {
            minPrice = price;
        } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
        }
    }
    return maxProfit;
};
```

**122. 买卖股票的最佳时机 II (Best Time to Buy and Sell Stock II)**
**核心**：贪心算法。只要今天比昨天高，就交易（收集所有正利润）。

```js
var maxProfit = function(prices) {
    let profit = 0;
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i-1]) {
            profit += prices[i] - prices[i-1];
        }
    }
    return profit;
};
```

### 2. 逆向与排列双指针 (Reverse & Permutation Pointers)
**88. 合并两个有序数组 (Merge Sorted Array)**
**核心**：逆向双指针。从后往前填，避免覆盖未处理的元素。

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1;
    let p2 = n - 1;
    let p = m + n - 1;
    
    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p] = nums1[p1];
            p1--;
        } else {
            nums1[p] = nums2[p2];
            p2--;
        }
        p--;
    }
    // 如果 nums2 还有剩余，直接拷贝 (nums1 剩余不用管，本来就在原地)
    while (p2 >= 0) {
        nums1[p] = nums2[p2];
        p2--;
        p--;
    }
};
```

**31. 下一个排列 (Next Permutation)**
**核心**：双指针寻找逆序对 + 反转。
**步骤**：
1. 从后往前找第一个升序对 `(i, i+1)`，满足 `nums[i] < nums[i+1]`。
2. 从后往前找第一个大于 `nums[i]` 的数 `nums[j]`。
3. 交换 `nums[i]` 和 `nums[j]`。
4. 反转 `i+1` 之后的所有元素。

```js
var nextPermutation = function(nums) {
    let i = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i+1]) i--; // 找第一个小
    
    if (i >= 0) {
        let j = nums.length - 1;
        while (j >= 0 && nums[j] <= nums[i]) j--; // 找第一个大
        [nums[i], nums[j]] = [nums[j], nums[i]]; // 交换
    }
    
    // 反转 i 之后的部分
    let left = i + 1, right = nums.length - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++; right--;
    }
};
```

### 3. 二维矩阵模拟 (Matrix Simulation)
**54. 螺旋矩阵 (Spiral Matrix)**
**核心**：模拟。设定上下左右四个边界，按顺序遍历并收缩边界。

```js
var spiralOrder = function(matrix) {
    if (!matrix.length) return [];
    let l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1;
    let res = [];
    
    while (true) {
        for (let i = l; i <= r; i++) res.push(matrix[t][i]); // left to right
        if (++t > b) break;
        for (let i = t; i <= b; i++) res.push(matrix[i][r]); // top to bottom
        if (--r < l) break;
        for (let i = r; i >= l; i--) res.push(matrix[b][i]); // right to left
        if (--b < t) break;
        for (let i = b; i >= t; i--) res.push(matrix[i][l]); // bottom to top
        if (++l > r) break;
    }
    return res;
};
```

**48. 旋转图像 (Rotate Image)**
**核心**：数学规律。先水平翻转（上下对称交换），再主对角线翻转（转置）。
**规律**：`matrix[i][j]` -> `matrix[j][n-1-i]`。

```js
var rotate = function(matrix) {
    const n = matrix.length;
    // 1. 水平翻转
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = 0; j < n; j++) {
            [matrix[i][j], matrix[n-1-i][j]] = [matrix[n-1-i][j], matrix[i][j]];
        }
    }
    // 2. 主对角线翻转
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
};
```

### 4. 区间与原地哈希 (Intervals & Cyclic Sort)
**56. 合并区间 (Merge Intervals)**
**核心**：排序 + 贪心。按起点排序，维护一个当前合并区间。

```js
var merge = function(intervals) {
    if (!intervals.length) return [];
    intervals.sort((a, b) => a[0] - b[0]);
    
    let res = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        let curr = intervals[i];
        let last = res[res.length - 1];
        
        if (curr[0] <= last[1]) {
            // 有重叠，合并（更新终点）
            last[1] = Math.max(last[1], curr[1]);
        } else {
            // 无重叠，加入新区间
            res.push(curr);
        }
    }
    return res;
};
```

**41. 缺失的第一个正数 (First Missing Positive)**
**核心**：原地 Hash (Cyclic Sort)。将数字 `x` 放在下标 `x-1` 的位置上。
**规则**：`nums[i]` 应该放在 `nums[i] - 1` 的位置。

```js
var firstMissingPositive = function(nums) {
    let n = nums.length;
    for (let i = 0; i < n; i++) {
        // 1. 也就是 nums[i] 在 [1, n] 范围内
        // 2. 且 nums[i] 没有放在正确的位置 (nums[i] != nums[nums[i]-1])
        while (nums[i] > 0 && nums[i] <= n && nums[i] !== nums[nums[i]-1]) {
            // 交换到正确位置
            let targetIndex = nums[i] - 1;
            [nums[i], nums[targetIndex]] = [nums[targetIndex], nums[i]];
        }
    }
    
    // 再次遍历，找第一个不匹配的
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) return i + 1;
    }
    return n + 1;
};
```

---

## 四、 拓展：链表中的双指针


1.  **判断环 (Linked List Cycle)**：快慢指针，快走二慢走一，相遇则有环。
2.  **找中点 (Middle of Linked List)**：快慢指针，快走完时慢在中点。
3.  **找倒数第 K 个 (Remove Nth Node From End)**：快指针先走 K 步，然后同步走。

```js
// 找倒数第 n 个节点
var getKthFromEnd = function(head, n) {
    let fast = head, slow = head;
    // 快指针先走 n 步
    while (n--) fast = fast.next;
    // 同步走，快指针到头时，慢指针就在倒数第 n 个
    while (fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
};
```
