# 双指针与滑动窗口 (Array & Two Pointers)

双指针技巧是解决数组和链表问题的最强工具之一。核心思想是将两层嵌套循环 ($O(N^2)$) 优化为单层循环 ($O(N)$)。

主要可分为两类：
1.  **快慢指针/左右指针**：解决原地修改、N数之和、接雨水等。
2.  **滑动窗口**：解决子串、子数组的匹配、长度、统计等问题。

---

## 一、 双指针通用模板

### 1. 左右指针 (对撞指针)
**适用场景**：二分查找、反转数组、N数之和、接雨水。
**核心思维**：数组有序（或需要排序），双向奔赴。

```javascript
var twoSum = function(nums, target) {
    // 1. 排序 (双指针的前提通常是有序)
    nums.sort((a, b) => a - b);
    
    let left = 0;
    let right = nums.length - 1;
    
    while (left < right) {
        let sum = nums[left] + nums[right];
        if (sum === target) {
            // 找到答案
            return [left, right];
        } else if (sum < target) {
            left++; // 让 sum 变大
        } else {
            right--; // 让 sum 变小
        }
    }
    return [];
};
```

### 2. 快慢指针 (原地操作)
**适用场景**：删除重复元素、移动零、原地移除元素。
**核心思维**：`slow` 维护合格区域，`fast` 探索新区域。

```javascript
// 示例：移除数组中的 val 元素
var removeElement = function(nums, val) {
    let slow = 0;
    for (let fast = 0; fast < nums.length; fast++) {
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
};
```

---

## 二、 滑动窗口万能模板 (Sliding Window)

**适用场景**：
-   寻找**最长/最短**子串或子数组
-   统计符合条件的子串个数
-   **关键词**：连续子数组、连续子串

**口诀**：
1.  **右移** (`right++`)：扩大窗口，寻找可行解。
2.  **收缩** (`left++`)：当窗口满足条件（或不满足限制）时，缩小窗口，寻找最优解。

```javascript
/* 滑动窗口通用模板 */
var slidingWindow = function(s) {
    // 1. 定义窗口所需的“数据结构” (Hash, Array, Counter)
    const window = new Map();
    
    // 2. 初始化左右边界
    let left = 0, right = 0;
    
    // 3. 记录结果变量 (最大长度、最小覆盖等)
    let res = 0; 

    // 4. 开始滑动：外层循环移动 right
    while (right < s.length) {
        // c 是将要移入窗口的字符
        let c = s[right];
        right++;
        
        // ---【进窗更新】---
        // 在这里更新窗口数据，比如 window.set(c, count + 1)
        
        /* debug 输出位置 */
        // console.log("window: [" + left + ", " + right + ")");

        // 5. 判断窗口是否要收缩：内层循环移动 left
        // CASE A: 求最小窗口 (如最小覆盖子串 76) -> 当窗口满足条件时，收缩以求最小
        // CASE B: 求最大窗口 (如无重复子串 3) -> 当窗口不满足条件(有重复)时，收缩直到满足
        while (/* window needs shrink */) {
            // d 是将要移出窗口的字符
            let d = s[left];
            left++;
            
            // ---【出窗更新】---
            // 在这里更新窗口数据，比如 window.set(d, count - 1)
        }
        
        // ---【结果更新】---
        // 如果求最大长度，通常在这里更新 res = Math.max(res, right - left)
        // 如果求最小长度，通常在里面 while 循环里更新
    }
    return res;
};
```

---

## 三、 经典题型解法

### 1. N数之和 (Two Sum / Three Sum)
**核心**：先**排序**，固定一个数，然后转化为 Two Sum 问题。
**注意**：去重逻辑是难点。

```javascript
// 三数之和伪代码
// 1. sort
// 2. for i in 0..n:
//      if nums[i] > 0 break (剪枝)
//      if i > 0 && nums[i] == nums[i-1] continue (去重 i)
//      left = i+1, right = n-1
//      while left < right:
//          sum = nums[i] + nums[left] + nums[right]
//          if sum == 0:
//              res.push(...)
//              while left < right && nums[left] == nums[left+1] left++ (去重 left)
//              while left < right && nums[right] == nums[right-1] right-- (去重 right)
//              left++, right--
```

### 2. 接雨水 (Trapping Rain Water)
**核心**：`min(l_max, r_max) - height[i]`
**双指针解法**：
1.  维护 `left`, `right` 两个指针。
2.  维护 `l_max`, `r_max` 代表左右两边的历史最高墙。
3.  每次移动**较矮**的那一边 (木桶效应)。

```javascript
// 接雨水双指针极简版
let left = 0, right = height.length - 1;
let l_max = 0, r_max = 0;
let ans = 0;
while (left < right) {
    l_max = Math.max(l_max, height[left]);
    r_max = Math.max(r_max, height[right]);
    
    // 哪边低，哪边就一定由这一边的 max 决定存水量
    if (l_max < r_max) {
        ans += l_max - height[left];
        left++;
    } else {
        ans += r_max - height[right];
        right++;
    }
}
```
