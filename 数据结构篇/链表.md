 ## 链表

### 核心点

- null/nil 异常处理
- dummy node 哑巴节点
- 快慢指针
- 插入一个节点到排序链表
- 从一个链表中移除一个节点
- 翻转链表
- 合并两个链表
- 找到链表的中间节点

### 通解与模板

#### 1. 核心解题思维

- **虚拟头节点 (Dummy Node)**:
  - **用途**: 统一处理头节点可能变化的情况（如删除、插入、合并）。
  - **通解**: `let dummy = new ListNode(-1); dummy.next = head;` 最后返回 `dummy.next`。

- **快慢指针 (Fast & Slow Pointers)**:
  - **用途**: 处理距离、环、中点类问题。
  - **场景**: 找中点（快2慢1）、判环、找倒数第 K 个节点。

- **多指针协作**:
  - **用途**: 链表无法随机访问，通常需要 `pre`, `cur`, `next` 配合完成断链、连链操作。

#### 2. 常见代码模板

**A. 虚拟头节点 (处理头节点变动)**

```js
var genericSolution = function(head) {
    let dummy = new ListNode(-1); // 哨兵节点
    dummy.next = head;
    let pre = dummy; 
    let cur = head;
    while (cur !== null) {
        // 逻辑处理...
        cur = cur.next;
    }
    return dummy.next;
};
```

**B. 快慢指针 (找中点/判环)**

```js
var findMiddle = function(head) {
    let slow = head;
    let fast = head.next; 
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow; 
};
```

**C. 反转链表 (迭代法)**

```js
var reverseList = function(head) {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let nextTemp = curr.next; 
        curr.next = prev;         
        prev = curr;              
        curr = nextTemp;
    }
    return prev; 
};
```

#### 3. 常见题型策略

| 题型分类       | 关键策略                                                                |
| :------------- | :---------------------------------------------------------------------- |
| **基础操作**   | **Dummy Node** 是神器。删除、插入操作都需要找到目标节点的**前驱节点**。 |
| **反转类**     | 熟练掌握 `pre`, `cur`, `next` 三指针迭代法。                            |
| **合并/排序**  | **归并排序**思想。找中点 -> 断开 -> 递归排序 -> 合并有序链表。          |
| **双指针技巧** | **快慢指针**找中点或判环；**双指针**分别遍历两个链表。                  |
| **重排/拼接**  | 组合拳：通常涉及 **找中点 + 反转后半部分 + 合并链表** 的步骤。          |

**链表的数据结构**

```js
/**
 * Definition for singly-linked list.
 */
function ListNode(val) {
     this.val = val;
     this.next = null;
 }
```

### 练习

##### 83.删除排序链表中的重复元素 [remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```js
var deleteDuplicates = function(head) {
    let cur = head;
    while(cur !== null && cur.next !== null){
        if(cur.val === cur.next.val){
            cur.next = cur.next.next;
        }else{
            cur = cur.next;
        }
    }
    return head;
};
```

```js
var deleteDuplicates = function(head) { // 递归写法
    if(head === null || head.next === null){
        return head;
    }
    head.next = deleteDuplicates(head.next);
    return head.val === head.next.val ? head.next : head;
};
```

##### 82.删除排序链表中的重复元素Ⅱ[remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

> 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。

```js
var deleteDuplicates = function(head) {
    let dummy = new ListNode(-1);
    dummy.next = head;
    let pre = dummy;
    while (pre.next !== null && pre.next.next !== null) {
        if (pre.next.val === pre.next.next.val) {
            let val = pre.next.val;
            while (pre.next !== null && pre.next.val === val) {
                pre.next = pre.next.next;
            }
        } else {
            pre = pre.next;
        }
    }
    return dummy.next;
}
```

##### 206.反转一个单链表（头插法）。[reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list/)

> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL

```js
var reverseList = function(head) {
    let prev = null;
    let cur = head;
    while (cur !== null) {
        let next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
};
```

##### 92.反转链表Ⅱ [reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。**说明:**1 ≤ *m* ≤ *n* ≤ 链表长度。

> 输入: 1->2->3->4->5->NULL, m = 2, n = 4
> 输出: 1->4->3->2->5->NULL

```js
var reverseBetween = function(head, m, n) {
    let dummy = new ListNode(-1);
    dummy.next = head;
    let pre = dummy;
    for (let i = 1; i < m; i++) {
        pre = pre.next;
    }
    let cur = pre.next;
    for (let i = 0; i < n - m; i++) {
        let next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy.next;
};
```

##### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

> 输入：1->2->4, 1->3->4
> 输出：1->1->2->3->4->4

```js
// 迭代法
var mergeTwoLists = function(l1, l2) {
    let dummy = new ListNode(-1);
    let pre = dummy;
    while (l1 !== null && l2 !== null) {
        if (l1.val <= l2.val) {
            pre.next = l1;
            l1 = l1.next;
        } else {
            pre.next = l2;
            l2 = l2.next;
        }
        pre = pre.next;
    }
    pre.next = l1 === null ? l2 : l1;
    return dummy.next;
};
```

```js
//递归
var mergeTwoLists = function(l1, l2) {
    if(l1 === null){
        return l2;
    }else if(l2 === null){
        return l1;
    }else if(l1.val <= l2.val){
        l1.next = mergeTwoLists(l1.next,l2);
        return l1;
    }else{
        l2.next = mergeTwoLists(l1,l2.next);
        return l2;
    }
};
```

##### 86.[分隔链表](https://leetcode-cn.com/problems/partition-list/) 

给定一个链表和一个特定值 *x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。你应当保留两个分区中每个节点的初始相对位置。

> 输入: head = 1->4->3->2->5->2, x = 3
> 输出: 1->2->2->4->3->5

```js
var partition = function(head, x) {
    let small = new ListNode(0);
    let smallHead = small;
    let large = new ListNode(0);
    let largeHead = large;
    while (head !== null) {
        if (head.val < x) {
            small.next = head;
            small = small.next;
        } else {
            large.next = head;
            large = large.next;
        }
        head = head.next;
    }
    large.next = null;
    small.next = largeHead.next;
    return smallHead.next;
};
```

##### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。`O(nlogn)`时间复杂度，常数级空间。

```js
var sortList = function(head) {
    return mergeSort(head);
};

const mergeSort = head => {
    if (head === null || head.next === null) {
        return head;
    }
    let slow = head;
    let fast = head.next.next;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    let mid = slow.next;
    slow.next = null;
    let left = mergeSort(head);
    let right = mergeSort(mid);
    return merge(left, right);
}

const merge = (l1, l2) => {
    let dummy = new ListNode(-1);
    let pre = dummy;
    while (l1 !== null && l2 !== null) {
        if (l1.val < l2.val) {
            pre.next = l1;
            l1 = l1.next;
        } else {
            pre.next = l2;
            l2 = l2.next;
        }
        pre = pre.next;
    }
    pre.next = l1 !== null ? l1 : l2;
    return dummy.next;
}
```

##### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```js
var reorderList = function(head) {
    if (head === null) return;
    let slow = head;
    let fast = head;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    let prev = null;
    let cur = slow.next;
    slow.next = null;
    while (cur !== null) {
        let next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    
    let head1 = head;
    let head2 = prev;
    while (head1 !== null && head2 !== null) {
        let next1 = head1.next;
        let next2 = head2.next;
        head1.next = head2;
        head1 = next1;
        head2.next = next1; // 修正逻辑：head1->head2->next1
        head2 = next2;
    }
};
```

##### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

```js
var hasCycle = function(head) {
    let slow = head;
    let fast = head;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) return true;
    }
    return false;
};
```

##### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

```js
var detectCycle = function(head) {
    let slow = head;
    let fast = head;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) {
            slow = head;
            while (slow !== fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};
```

##### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

**核心思路：双指针（浪漫相遇）**
- 指针 `pA` 遍历 `A`，遍历完后跳转到 `headB`。
- 指针 `pB` 遍历 `B`，遍历完后跳转到 `headA`。
- 两个指针走过的总路程相同（`lenA + lenB`），如果相交，它们必会在交点处相遇；如果不相交，它们必会同时指向 `null`。

```js
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) return null;
    let pA = headA;
    let pB = headB;
    
    // 只要不相等就继续走
    while (pA !== pB) {
        // 走完 A 就走 B，走完 B 就走 A
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    
    return pA;
};
```

##### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

请判断一个链表是否为回文链表。

```js
var isPalindrome = function(head) {
    let slow = head;
    let fast = head;
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    let prev = null;
    let cur = slow;
    while (cur !== null) {
        let next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    
    let p1 = head;
    let p2 = prev;
    while (p2 !== null) {
        if (p1.val !== p2.val) return false;
        p1 = p1.next;
        p2 = p2.next;
    }
    return true;
};
```

##### [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

```js
var copyRandomList = function(head) {
    if (head === null) return null;
    let cur = head;
    while (cur !== null) {
        let clone = new Node(cur.val, cur.next, null);
        cur.next = clone;
        cur = clone.next;
    }
    cur = head;
    while (cur !== null) {
        if (cur.random !== null) {
            cur.next.random = cur.random.next;
        }
        cur = cur.next.next;
    }
    cur = head;
    let cloneHead = cur.next;
    while (cur.next !== null) {
        let temp = cur.next;
        cur.next = cur.next.next;
        cur = temp;
    }
    return cloneHead;
}; 
```


##### [23. 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

**方式一：分治法（归并思想）**

```js
var mergeKLists = function(lists) {
    if (lists.length === 0) return null;
    return solve(lists, 0, lists.length - 1);
};

function solve(lists, left, right) {
    if (left === right) return lists[left];
    let mid = Math.floor((left + right) / 2);
    let l1 = solve(lists, left, mid);
    let l2 = solve(lists, mid + 1, right);
    return mergeTwoLists(l1, l2);
}

function mergeTwoLists(l1, l2) {
    let dummy = new ListNode(-1);
    let pre = dummy;
    while (l1 && l2) {
        if (l1.val < l2.val) {
            pre.next = l1;
            l1 = l1.next;
        } else {
            pre.next = l2;
            l2 = l2.next;
        }
        pre = pre.next;
    }
    pre.next = l1 || l2;
    return dummy.next;
}
```

**方式二：优先级队列（最小堆）**

> JS 需手写堆，面试中建议优先使用分治法。

```js
var mergeKLists = function(lists) {
    let dummy = new ListNode(-1);
    let p = dummy;
    let pq = new MinHeap((a, b) => a.val < b.val); // 伪代码：假设有最小堆

    for (let head of lists) {
        if (head) pq.push(head);
    }

    while (!pq.isEmpty()) {
        let node = pq.pop();
        p.next = node;
        if (node.next) pq.push(node.next);
        p = p.next;
    }
    return dummy.next;
};
```

##### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

```js
var reverseKGroup = function(head, k) {
    let cur = head;
    let count = 0;
    // 探测是否够 k 个
    while (cur !== null && count !== k) {
        cur = cur.next;
        count++;
    }
    if (count === k) {
        // 反转这 k 个节点
        let prev = null;
        let node = head;
        for (let i = 0; i < k; i++) {
            let next = node.next;
            node.next = prev;
            prev = node;
            node = next;
        }
        // 递归连接
        head.next = reverseKGroup(cur, k);
        return prev;
    }
    return head;
};
```

##### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

**核心思想**：
- **哈希表 (Map)**：用于 $O(1)$ 时间复杂度通过 `key` 快速定位节点。
- **双向链表 (Doubly Linked List)**：用于 $O(1)$ 时间复杂度增加/删除节点，并维护访问顺序。
  - 靠近 **虚拟头节点 (head)** 的是最近访问的。
  - 靠近 **虚拟尾节点 (tail)** 的是最久未访问的。

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.capacity = capacity;
    this.map = new Map(); // key -> node
    this.head = new ListNode(-1, -1); // 虚拟头
    this.tail = new ListNode(-1, -1); // 虚拟尾
    this.head.next = this.tail;
    this.tail.prev = this.head;
};

function ListNode(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
}

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (!this.map.has(key)) return -1;
    const node = this.map.get(key);
    this.moveToHead(node); // 访问后移到头部
    return node.val;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.map.has(key)) {
        const node = this.map.get(key);
        node.val = value;
        this.moveToHead(node);
    } else {
        if (this.map.size === this.capacity) {
            const lastNode = this.tail.prev;
            this.removeNode(lastNode);
            this.map.delete(lastNode.key);
        }
        const newNode = new ListNode(key, value);
        this.addNodeToHead(newNode);
        this.map.set(key, newNode);
    }
};

// 辅助函数：将节点移到头部
LRUCache.prototype.moveToHead = function(node) {
    this.removeNode(node);
    this.addNodeToHead(node);
};

// 辅助函数：删除节点
LRUCache.prototype.removeNode = function(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
};

// 辅助函数：在头部插入节点
LRUCache.prototype.addNodeToHead = function(node) {
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
};
```

## 练习


-  [remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
-  [remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
-  [reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list/)
-  [reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
-  [merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
-  [partition-list](https://leetcode-cn.com/problems/partition-list/)
-  [sort-list](https://leetcode-cn.com/problems/sort-list/)
-  [reorder-list](https://leetcode-cn.com/problems/reorder-list/)
-  [linked-list-cycle](https://leetcode-cn.com/problems/linked-list-cycle/)
-  [linked-list-cycle-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
-  [palindrome-linked-list](https://leetcode-cn.com/problems/palindrome-linked-list/)
-  [copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
-  [reverse-nodes-in-k-group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
-  [merge-k-sorted-lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
