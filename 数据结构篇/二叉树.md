## 二叉树

### 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树。**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树。**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**。

注意点：

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

## 二叉树通解与模板

二叉树题目的本质只有两点：
1.  **怎么遍历？** (DFS 还是 BFS？前/中/后序？)
2.  **在遍历的每个节点上做什么？** (处理逻辑)

### 一、 递归通解：两大思维模式

递归是二叉树的灵魂。做题时不要试图跳进递归的每一层去人脑压栈，而是要利用**数学归纳法**的思维：**只关注当前节点要做什么，假定子树已经做好了**。

#### 1. 模式一：遍历思维 (Traverse / Top-down)
**核心思想**：带着一个“全局变量”或者“状态参数”跑遍整棵树，走到哪更新到哪。一般没有返回值（`void`）。
**适用场景**：路径总和、输出所有路径、单纯的遍历打印。

```js
// 遍历思维模板
let result; // 1. 定义全局结果

var traverse = function(root) {
    // 2. 初始化结果
    result = []; 
    dfs(root);
    return result;
};

var dfs = function(root) {
    // 3. Base Case：空节点直接返回
    if (root === null) {
        return;
    }

    // --- 前序位置 (进入节点前) ---
    // 这里的逻辑是：处理当前节点
    // result.push(root.val); 
    
    dfs(root.left);  // 递归遍历左子树
    dfs(root.right); // 递归遍历右子树

    // --- 后序位置 (离开节点后) ---
    // 这里的逻辑是：如果需要在离开节点时撤销选择（回溯法）写在这里
};
```

#### 2. 模式二：分治思维 (Divide & Conquer / Bottom-up)
**核心思想**：**大部分二叉树难题的解法**。让左右子树分别去干活，把结果**返回**给你，你在当前节点把结果组合起来。
**适用场景**：最大深度、是否平衡、最近公共祖先、最大路径和。

**口诀**：
1.  **也就是问左右子树要什么？** (定义递归函数的返回值)
2.  **当前节点拿到左右子树的返回值，怎么处理？** (合并逻辑)
3.  **当前节点应该返回给父节点什么？** (向上层汇报)

```js
// 分治思维模板
var divideAndConquer = function(root) {
    // 1. Base Case
    if (root === null) {
        return null; // 或者 0, [], false, 根据题目要求
    }

    // 2. 分 (Divide)：通过递归获得左右子树的结果
    let leftResult = divideAndConquer(root.left);
    let rightResult = divideAndConquer(root.right);

    // 3. 治 (Conquer)：在当前节点处理（合并）结果
    // 比如：最大深度 = max(left, right) + 1
    let currentResult = /* 根据 leftResult 和 rightResult 算出当前节点结果 */;

    // 4. 返回给上一层
    return currentResult;
};
```

### 二、 迭代通解：层序遍历 (BFS)

**核心思想**：只要题目提到“按层”、“最小步数”、“最短路径”或需要一层层处理，立刻想到 **Queue (队列)**。

**模板** (背下来，直接套用)：

```js
// BFS 层序遍历模板
var levelOrder = function(root) {
    if (root === null) return [];
    
    const queue = [root]; // 1. 初始化队列，放入根节点
    const res = [];

    while (queue.length > 0) {
        const size = queue.length; // 2. 锁定当前层的节点个数(必须先存size，因为queue长度会变)
        const currentLevel = [];   // 存放当前层结果

        // 3. 遍历当前层的每一个节点
        for (let i = 0; i < size; i++) {
            const node = queue.shift(); //以此取出队头
            currentLevel.push(node.val);

            // 4. 将下一层的节点放入队列
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        res.push(currentLevel); // 收集每一层的结果
    }
    return res;
};
```

### 三、 二叉搜索树 (BST) 特效药

如果是 **BST (Binary Search Tree)** 题目，切记一个核心性质：
> **BST 的中序遍历 是一个 有序数组**

**通用解法**：
1.  **验证 BST**：中序遍历看是否递增。
2.  **BST 第 K 小元素**：中序遍历第 K 个。
3.  **BST 转累加树**：反向中序遍历 (右->根->左)。

```js
// BST 通用中序处理
var bstProcessor = function(root) {
    if (root === null) return;

    bstProcessor(root.left);
    
    // --- 中序位置 ---
    // 此时已经是有序的了
    // print(root.val)
    
    bstProcessor(root.right);
}
```

### 四、非递归 DFS 统一模板 (颜色标记法)

**痛点**：传统非递归写法前中后序逻辑不一致（前序简单，中序需嵌套循环，后序需反转或者双栈），导致很难记忆。
**解决方案**：**“颜色标记法”**。通过压栈 `null` (或特定标记) 来区分“访问节点”与“处理节点”。

**模板口诀**：**栈是后进先出，入栈顺序与遍历顺序相反**。
1. 遇到节点 -> 将其与子节点按 **反向顺序** 入栈。
2. 遇到待处理节点（中节点） -> 放入栈中，并紧跟一个 `null` 标记。
3. 遇到 `null` -> 弹出下一个节点，加入结果集。

```js
// 统一模板：只需要调整入栈顺序即可实现前中后序
var traversal = function(root) {
    const res = [];
    const stack = [];
    if (root) stack.push(root);

    while (stack.length > 0) {
        const node = stack.pop();

        if (!node) { // 1. 遇到标记
            res.push(stack.pop().val); // 2. 处理标记后的节点
            continue;
        }

        // 3. 按照遍历顺序的 **逆序** 入栈
        // --- 示例：中序遍历 (左 -> 中 -> 右) ---
        // 入栈顺序：右 -> 中(标记) -> 左
        
        if (node.right) stack.push(node.right); // 右
        
        stack.push(node); 
        stack.push(null); // 中 (打标记，代表待处理)
        
        if (node.left) stack.push(node.left);   // 左
    }
    return res;
};
```

**不同遍历顺序的入栈变换**：

- **前序 (中左右)** -> 入栈：右 -> 左 -> 中(mark)
- **中序 (左中右)** -> 入栈：右 -> 中(mark) -> 左
- **后序 (左右中)** -> 入栈：中(mark) -> 右 -> 左

### 五、 记忆心法总结

1.  **看到“最大”、“所有路径”** -> 优先想 **DFS** (递归)。
    -   如果需要由下向上反推 (如树高、直径) -> **分治法 (后序)**。
    -   如果需要自顶向下携带参数 (如路径和匹配) -> **遍历法 (前序)**。
2.  **看到“层级”、“最短”、“宽度”** -> 优先想 **BFS** (Queue)。
3.  **操作当前节点**：
    -   **前序**：哪怕我不知道子树情况，我也能先处理自己 (比如打印)。
    -   **中序**：BST 专用 (有序)。
    -   **后序**：必须等子树汇报完情况，我才能做决定 (比如删节点、算高度、LCA)。

#### 树结构

```tsx
function TreeNode(val){
    this.val = val;
    this.left = null;
    this.right = null;
}

class TreeNode { // es6 + ts
		val: any
		left: TreeNode | null
		right: TreeNode | null
		constructor(val: any){
      	this.val = val
      	this.left = null
      	this.right = null
    }
}
```

#### 根据数组构建二叉树

```js
const buildTreeByArray = function (array, index) {
    let tn = null;
    if (index < array.length) {
        const value = array[index];
        if (value !== null) {
            tn = new TreeNode(value);
            tn.left = buildTreeByArray(array, 2 * index + 1);
            tn.right = buildTreeByArray(array, 2 * index + 2);
        }
        return tn;
    }
    return tn;
}

const binaryTree = function (array) {
    return buildTreeByArray(array, 0);
}

const arr = [1,2,3,null,4,5,null,null,null,6,7];
let root = binaryTree(arr);
```

#### 前序递归

```js
// 1. 前序递归 (PreOrder) - Template Style
// 采用 "遍历思维" 模板
var preorderTraversal = function(root) {
    const res = [];
    const dfs = (node) => {
        if(node === null) return;
        
        // 前序位置：处理节点
        res.push(node.val);
        
        dfs(node.left);
        dfs(node.right);
    }
    dfs(root);
    return res;
};
```

#### 前序非递归

```js
// 2. 前序非递归 (PreOrder Iterative)
// 方法一：标准栈写法 (Standard)
const preOrderTraversal = function (root) {
    if(root === null) return [];
    
    const res = [];
    const stack = [root];
    
    while(stack.length > 0){
        const node = stack.pop();
        res.push(node.val);
        
        // 先压右，后压左 -> 出栈就是 左，右
        if (node.right !== null) stack.push(node.right);
        if (node.left !== null) stack.push(node.left);
    }
    return res;
}
// 方法二：颜色标记法 (Unified) - 见下文通用模板章节
```

#### 中序递归

```js
// 3. 中序递归 (InOrder) - Template Style
var inorderTraversal = function(root){
    const res = [];
    const dfs = (node) => {
        if(node === null) return;
        
        dfs(node.left);
        // 中序位置
        res.push(node.val);
        dfs(node.right);
    }
    dfs(root);
    return res;
}
```

#### 中序非递归

```js
// 4. 中序非递归 (InOrder Iterative)
// 标准栈写法
const inOrderTraversal = function(root){
    const res = [];
    const stack = [];
    let node = root;
    
    while(stack.length > 0 || node !== null){
        // 不断往左走
        while(node !== null){
            stack.push(node);
            node = node.left;
        }
        // 走到头了，弹出并处理
        node = stack.pop();
        res.push(node.val);
        // 转向右边
        node = node.right;
    }
    return res;
}
```

#### 后序递归

```js
// 5. 后序递归 (PostOrder) - Template Style
var postorderTraversal = function(root){
    const res = [];
    const dfs = (node) => {
        if(node === null) return;
        
        dfs(node.left);
        dfs(node.right);
        // 后序位置
        res.push(node.val);
    }
    dfs(root);
    return res;
}
```

#### 后序非递归

```js
// 6. 后序非递归 (PostOrder Iterative)
// 方法：前序(中左右) -> 变形(中右左) -> 反转res(左右中)
const postOrderTraversal = function(root){
    if (root === null) return [];
    
    const res = [];
    const stack = [root];
    
    while(stack.length > 0){
        const node = stack.pop();
        res.push(node.val);
        
        // 先压左，后压右 -> 出栈是 右，左
        // 配合 push(val) -> 结果是 中，右，左
        if (node.left !== null) stack.push(node.left);
        if (node.right !== null) stack.push(node.right);
    }
    // 反转 -> 左，右，中
    return res.reverse();
}
```

#### 深度搜索DFS

```js
// 7. 深度搜索 DFS (Template)
// 等同于 "遍历思维" 模板
const dfsRecursive = function(root){
    const res = [];
    const dfs = (node) => {
        if (node === null) return;
        
        res.push(node.val); // 前序位置
        dfs(node.left);
        dfs(node.right);
    }
    dfs(root);
    return res;
}

// 分治法 (Divide & Conquer)
// 适用于：自底向上，或者合并左右子树结果
const divideAndConquer = function(node){
    const res = [];
    if (node === null) return []; // 注意：分治法的 Base Case 返回值通常取决于题目，这里也是[]
    
    const left = divideAndConquer(node.left);
    const right = divideAndConquer(node.right);
    
    // 合并逻辑 (Conquer)
    res.push(node.val);
    if(left) res.push(...left);
    if(right) res.push(...right);
    
    return res;
}
```

#### 广度搜索BFS

```js
// 8. 广度搜索 BFS (Template)
// 使用标准的队列模板
var levelOrder = function(root) {
    if (root === null) return [];
    
    const queue = [root];
    const res = [];

    while (queue.length > 0) {
        // level size
        const size = queue.length;
        // current level nodes
        const currentLevel = []; 

        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        res.push(currentLevel); // Store level by level
    }
    return res;
};
```

[104.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。**说明:** 叶子节点是指没有子节点的节点。

> 给定二叉树 [3,9,20,null,null,15,7]，
>
>       3
>      / \
>     9  20
>         /  \
>      15   7
>
> 返回它的最大深度 3 。

```js
const maxDepth = function(root) {
    // 1. Base Case
    if(root === null){
        return 0;
    }
    // 2. Divide
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    // 3. Conquer (Merge)
    return Math.max(leftDepth, rightDepth) + 1;
};
```

[110.平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

```js
const isBalanced = function(root) {
    // 利用后续分治，如果返回 -1 代表不平衡
    return maxDepth(root) !== -1;
};

const maxDepth = function(root) {
    // 1. Base Case
    if(root === null) {
        return 0;
    }
    // 2. Divide
    const left = maxDepth(root.left);
    const right = maxDepth(root.right);
    
    // 3. Conquer (Check Balance)
    // 如果子树已经不平衡，或者当前节点不平衡，直接返回-1标记
    if(left === -1 || right === -1 || Math.abs(left - right) > 1) {
        return -1;
    }
    
    return Math.max(left, right) + 1;
}
```

[124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点—子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。
**路径和** 是路径中各节点值的总和。
给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

```js
var maxPathSum = function (root) {
    let maxSum = Number.MIN_SAFE_INTEGER;
    
    // 分治函数：计算以当前节点为根的单边最大路径和
    const dfs = (node) => {
        // 1. Base Case
        if (node === null) {
            return 0;
        }
        
        // 2. Divide: 计算左右子树的单边最大贡献（负数也不选）
        const leftGain = Math.max(dfs(node.left), 0);
        const rightGain = Math.max(dfs(node.right), 0);
        
        // 3. Conquer (Update Global Max): 更新全局最大路径和（包含当前节点和左右子树）
        const currentPathSum = node.val + leftGain + rightGain;
        maxSum = Math.max(maxSum, currentPathSum);
        
        // 4. Return: 返回当前节点的最大单边路径和给父节点
        return node.val + Math.max(leftGain, rightGain);
    }
    
    dfs(root);
    return maxSum;
};
```

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```js
var lowestCommonAncestor = function (root, p, q) {
    // 1. Base Case
    // 如果是空，或者找到了 p 或 q，直接返回当前节点
    if (root === null || root === p || root === q) {
        return root;
    }

    // 2. Divide
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);

    // 3. Conquer
    // 如果左右都找到了，说明当前节点是 LCA
    if (left !== null && right !== null) {
        return root;
    }
    // 否则返回非空的那个（即找到了 p 或 q 的那一边）
    return left !== null ? left : right;
};
```

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。

```js
// 严格套用 BFS 模板
var levelOrder = function (root) {
    if (root === null) return [];
    
    const queue = [root];
    const res = [];
    
    while (queue.length > 0) {
        // 一次处理一层
        const size = queue.length; 
        const level = [];
        
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            level.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        res.push(level);
    }
    return res;
};
```

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

```js
var isSymmetric = function(root) {
    if(root === null) return true;
    
    // 递归判断两个子树是否互为镜像
    const check = (left, right) => {
        // 1. Base Case
        if (left === null && right === null) return true; // 都为空，对称
        if (left === null || right === null) return false; // 一个空一个不空，不对称
        
        // 2. Divide: 判断 
        // A. 根节点值是否相同
        if (left.val !== right.val) return false;
        
        // B. 递归比较：左子树的左 vs 右子树的右，左子树的右 vs 右子树的左
        return check(left.left, right.right) && check(left.right, right.left);
    }
    
    return check(root.left, root.right);
};
```

[LCR 143. 树的子结构 (剑指 Offer 26)](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)
**注意**：子结构不等于子树。子结构只需要“局部匹配”即可，不需要匹配到叶子节点。

```js
var isSubStructure = function(A, B) {
    // 特殊约定：空树不是子结构
    if (!A || !B) return false;
    
    // 1. Base Case: 以当前节点匹配
    // 2. Divide: 否则去左子树找，或者去右子树找
    return isSame(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
};

const isSame = (A, B) => {
    // 关键点：B 匹配完了，说明找到了，返回 true
    if (!B) return true;
    // B 没完但 A 完了，说明匹配不上，返回 false
    if (!A) return false;
    
    // 值不同，匹配失败
    if (A.val !== B.val) return false;
    
    // 必须左右同时匹配
    return isSame(A.left, B.left) && isSame(A.right, B.right);
}
```

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。计算从根到叶子节点生成的所有数字之和。

```js
var sumNumbers = function(root) {
    // 套用【遍历思维】模板 (Traverse)
    // 这里的“全局变量”是 dfs 函数的参数，也可以写在外面
    let sum = 0;
    
    const dfs = (node, curNum) => {
        // 1. Base Case
        if (node === null) return;
        
        // 2. 前序位置：更新当前路径的数字
        curNum = curNum * 10 + node.val;
        
        // 3. 判断叶子节点：如果到了叶子，累加结果
        if (node.left === null && node.right === null) {
            sum += curNum;
            return;
        }
        
        // 4. 继续遍历左右子树
        dfs(node.left, curNum);
        dfs(node.right, curNum);
    }
    
    dfs(root, 0);
    return sum;
};
```

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定一棵树的前序遍历 `preorder` 与中序遍历  `inorder`。请构造二叉树并返回其根节点。

```js
var buildTree = function(preorder, inorder) {
    // 套用【分治思维】模板
    // 1. Base Case: 序列为空，返回 null
    if (preorder.length === 0 || inorder.length === 0) {
        return null;
    }
    
    // 2. 根节点：前序遍历的第一个元素
    const rootVal = preorder[0];
    const root = new TreeNode(rootVal);
    
    // 3. 找到根节点在中序遍历中的位置，以此划分左右子树
    const index = inorder.indexOf(rootVal);
    
    // 4. Divide: 切割数组，递归构建左右子树
    // 左子树的中序：[0, index)
    // 左子树的前序：[1, index + 1)  (长度要和中序一致)
    root.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
    
    // 右子树的中序：[index + 1, end)
    // 右子树的前序：[index + 1, end)
    root.right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
    
    // 5. Return: 返回构建好的根节点
    return root;
};
```

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```js
var levelOrderBottom = function(root) {
    // 套用 BFS 模板，只是最后存结果用 unshift
    if (root === null) return [];
    
    const queue = [root];
    const res = [];
    
    while (queue.length > 0) {
        const size = queue.length;
        const level = [];
        
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            level.push(node.val);
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        res.unshift(level); // 与标准 BFS 唯一的区别：从头部插入结果
    }
    return res;
};
```

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```js
var rightSideView = function(root) {
    // 套用 BFS 模板
    if (root === null) return [];
    
    const queue = [root];
    const res = [];
    
    while (queue.length > 0) {
        const size = queue.length;
        // 这一层的最后一个元素，就是右视图看到的元素
        
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            
            // 如果是当前层的最后一个节点，放入结果集
            if (i === size - 1) {
                res.push(node.val);
            }
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
    }
    return res;
};
```

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

```js
var zigzagLevelOrder = function(root) {
    // 套用 BFS 模板，处理每一层的顺序不同
    if (root === null) return [];
    
    const queue = [root];
    const res = [];
    let isOrderLeft = true; // 标记方向
    
    while (queue.length > 0) {
        const size = queue.length;
        const level = []; // 使用双端队列思想 (这里简单用数组配合反转)
        
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            if (isOrderLeft) {
                level.push(node.val);
            } else {
                level.unshift(node.val); // 倒序就从头插，或者等push完再reverse
            }
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        res.push(level);
        isOrderLeft = !isOrderLeft;
    }
    return res;
};
```

[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。
**注意**：本题的关键在于节点可能是 `null`，但计算宽度时要视为存在（空节点也要占位）。

```js
var widthOfBinaryTree = function(root) {
    // 套用 BFS 模板，但需要给节点编号
    // 编号规则：root 为 1，左孩子为 2*i，右孩子为 2*i+1
    // 关键点：JS数字如果是大数，会精度丢失，需要用 BigInt
    
    if (root === null) return 0;
    
    // queue 存放 [node, index]
    // 初始 index 用 1n (BigInt)
    const queue = [[root, 1n]];
    let maxWidth = 0;
    
    while (queue.length > 0) {
        const size = queue.length;
        
        // 记录当前层的 最左索引 和 最右索引
        // 肯定分别是队头和队尾（因为是层序的）
        // 但注意：for循环执行完后，queue 里剩下的就是下一层的了，所以要在本层开始前记录，或者在循环中记录
        
        let leftIndex, rightIndex;
        // 如果想要方便，可以在循环开始前取头尾
        // 队头就是本层最左，队尾是本层最右
        if (size > 0) {
           leftIndex = queue[0][1];
           rightIndex = queue[queue.length - 1][1];
           // 计算宽度，并转换为 Number
           maxWidth = Math.max(maxWidth, Number(rightIndex - leftIndex + 1n));
        }

        for (let i = 0; i < size; i++) {
            const [node, index] = queue.shift();
            
            if (node.left) queue.push([node.left, index * 2n]);
            if (node.right) queue.push([node.right, index * 2n + 1n]);
        }
    }
    return maxWidth;
};
```

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```js
var isValidBST = function (root) {
    // 利用 BST 性质：中序遍历是有序的
    let pre = -Infinity;
    
    // 返回值：是否合法
    const dfs = (node) => {
        if (node === null) return true;
        
        // 左
        if (!dfs(node.left)) return false;
        
        // 根 (检查是否大于前一个值)
        if (node.val <= pre) return false;
        pre = node.val;
        
        // 右
        return dfs(node.right);
    }
    
    return dfs(root);
};
```

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

```js
var insertIntoBST = function (root, val) {
    // 递归查找插入位置，天然利用 BST 的性质
    if (root === null) {
        return new TreeNode(val);
    }
    
    // 这是一个只遍历单边子树的过程，类似二分查找
    if (root.val > val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
};
```

## 练习

-  [maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
-  [balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree/)
-  [symmetric-tree](https://leetcode-cn.com/problems/symmetric-tree/)
-  [tree-substructure](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)
-  [sum-root-to-leaf-numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
-  [construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
-  [binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
-  [lowest-common-ancestor-of-a-binary-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
-  [binary-tree-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
-  [binary-tree-level-order-traversal-ii](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
-  [binary-tree-right-side-view](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
-  [binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
-  [maximum-width-of-binary-tree](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)
-  [validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)
-  [insert-into-a-binary-search-tree](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)